"""
A module allowing exploitation of the Hdf5 output database
"""
from __future__ import print_function
import sys
import h5py
import numpy as np
from bisect import bisect
from xvof.output_manager.truefieldsbuilder import build_cell_true_field, build_node_true_field


class OutputDatabaseExploit(object):
    """
    A class for exploiting the output stored in Hdf5 database
    """
    field_type_converter = {"Pressure": ("ClassicalPressure", "EnrichedPressure"),
                            "Density": ("ClassicalDensity", "EnrichedDensity"),
                            "InternalEnergy": ("ClassicalInternalEnergy", "EnrichedInternalEnergy"),
                            "SoundVelocity": ("ClassicalSoundVelocity", "EnrichedSoundVelocity"),
                            "ArtificialViscosity": ("ClassicalArtificialViscosity", "EnrichedArtificialViscosity"),
                            "NodeVelocity": ("ClassicalNodeVelocity", "EnrichedNodeVelocity"),
                            "NodeCoordinates": ("NodeCoordinates", "None"),
                            "NodeStatus": ("NodeStatus", "None"),
                            "CellStatus": ("CellStatus", "None")}

    def __init__(self, path_to_db):
        self.__db = h5py.File(path_to_db)
        self.__saved_times = sorted([float(x) for x in self.__db.keys()])
        self.__nb_saved_times = len(self.saved_times)
        self.__saved_fields = self.__db.values()[0].keys()
        self.__saved_fields_type = [k for k, v in OutputDatabaseExploit.field_type_converter.items()
                                    if v[0] in self.__saved_fields]

    @property
    def nb_saved_times(self):
        """
        Return the number of time step that have been saved

        :return: the number of time step that have been saved
        """
        return self.__nb_saved_times

    @property
    def saved_times(self):
        """
        Return the list of saved times

        :return: the list of saved times
        """
        return self.__saved_times

    @property
    def saved_fields(self):
        """
        Return the different fields stored in the database

        :return: the different fields stored in the database
        """
        return self.__saved_fields

    @property
    def saved_fields_type(self):
        """
        Return the different fields type stored in the database

        :return: the different fields type stored in the database
        """
        return self.__saved_fields_type

    def get_cells_true_size_at_time(self, time):
        """
        Return the cells true sizes at time time

        :param time: time at which the cells sizes are computed
        :return: the cells true sizes
        """
        size = np.copy(self.extract_field_at_time("CellSize", time))
        left_size, right_size = None, None
        try:
            left_size = self.extract_field_at_time("CellLeftSize", time)
            right_size = self.extract_field_at_time("CellRightSize", time)
        except KeyError:
            pass
        if left_size is not None and right_size is not None:
            offset = 0
            for stable_index in np.where(left_size)[0]:
                moving_index = stable_index + offset
                size = np.insert(size, moving_index, [left_size[moving_index], right_size[moving_index]])
                offset += 2
                size = np.delete(size, stable_index + offset)
        return size

    def get_cells_coordinate(self, time):
        """
        Return the cells center coordinate at time time
        :param time: time at which the cells coordinates are computed
        :return: the cells center coordinates
        """
        # Prise en compte de la longueur de la discontinuite :
        node_position = np.copy(self.extract_field_at_time("NodeCoordinates", time)).flatten()
        cell_size = np.copy(self.extract_field_at_time("CellSize", time))
        left_size, right_size = None, None
        try:
            left_size = self.extract_field_at_time("CellLeftSize", time)
            right_size = self.extract_field_at_time("CellRightSize", time)
        except KeyError:
            pass
        if left_size is not None and right_size is not None:
            for stable_index in np.where(left_size)[0]:
                # on dedouble la position du noeud enrichi de droite
                node_position = np.insert(node_position, stable_index+1, node_position[stable_index+1])
                # on remplace la taille de la cell rompue par sa taille gauche et sa taille droite
                cell_size = np.insert(cell_size, stable_index, [left_size[stable_index], right_size[stable_index]])
                offset = 2
                cell_size = np.delete(cell_size, stable_index + offset)
            # if np.where(left_size)[0]:
                # import ipdb ; ipdb.set_trace()
        cell_position = node_position[:-1] + cell_size / 2.
        # rectification pour la moitie droite de la cell enrichie :
        if left_size is not None and right_size is not None:
            for index in np.where(right_size)[0]:
                cell_position[index] -= cell_size[index]

        return cell_position.reshape((len(cell_size), 1))


    def extract_field_at_time(self, field_name, time):
        """
        Return the value of the specified field at time time in a numpy array

        :param field_name: name of the field to be extracted
        :param time: time at which the field has to be extracted
        :return: the values of the field at time time
        """
        ex_time = time
        if not ex_time in self.saved_times:
            ex_time_index = bisect(self.saved_times, time)
            if ex_time_index == self.nb_saved_times:
                ex_time_index = self.nb_saved_times - 1
            try:
                ex_time = self.saved_times[ex_time_index]
            except IndexError:
                print("Specified times is out of range. Please specify a time in [{:15.9g}, {:15.9g}]"
                      .format(self.saved_times[0], self.saved_times[-1]), file=sys.stderr)
                raise
        try:
            if ex_time != 0.:
                field = self.__db[str(ex_time)][field_name]
            else:
                field = self.__db['0'][field_name]
        except KeyError:
            if field_name not in self.saved_fields:
                print("The {:s} field is not present in the database!".format(field_name), file=sys.stderr)
                raise
            else:
                print("Unable to retrieve the group {:s}".format(str(ex_time)), file=sys.stderr)
                raise
        return field

    def extract_true_field_at_time(self, field_type, time):
        """
        Return the value of the true field at time time in a numpy array

        :param field_type: type of the true field ("Pressure", "Density" ...)
        :param time: time at which the field has to be extracted
        :return: the values of the true field at time time
        """
        try:
            classical_fname, enriched_fname = OutputDatabaseExploit.field_type_converter[field_type]
        except KeyError:
            print("The field type {:s} is not present in the database. Available field types are {:s}!"
                  .format(field_type, ",".join(self.saved_fields_type)), file=sys.stderr)
        classical_f = self.extract_field_at_time(classical_fname, time)
        enriched_f = None
        true_field = None
        x_f = None
        try:
            enriched_f = self.extract_field_at_time(enriched_fname, time)
        except KeyError:
            pass
        if enriched_f is None:
            true_field = classical_f
            if classical_f.attrs["support"] in ["OneDimensionEnrichedNode", "OneDimensionNode"]:
                x_f = self.extract_field_at_time("NodeCoordinates", time)
            elif classical_f.attrs["support"] in ["OneDimensionEnrichedCell", "OneDimensionCell"]:
                x_f = self.get_cells_coordinate(time)
        else:
            if classical_f.attrs["support"] in ["OneDimensionEnrichedNode", "OneDimensionNode"]:
                status_f = self.extract_field_at_time("NodeStatus", time)
                x_f = self.extract_field_at_time("NodeCoordinates", time)
                true_field = build_node_true_field(classical_f, enriched_f, status_f)
            elif classical_f.attrs["support"] in ["OneDimensionEnrichedCell", "OneDimensionCell"]:
                status_f = self.extract_field_at_time("CellStatus", time)
                x_f = self.get_cells_coordinate(time)
                true_field = build_cell_true_field(classical_f, enriched_f, status_f)
            else:
                raise ValueError("Unknown support value!")
        return np.concatenate((x_f, true_field), axis=1)
