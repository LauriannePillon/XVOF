#!/usr/bin/env python2.7
# -*- coding: iso-8859-15 -*-
""" 
Class to posttreat experimental data
"""

import matplotlib.pyplot as plt
import numpy as np
import os
from xfv.src.data.data_container import DataContainer


class ExperimentalData(object):
    """
    Class to define posttreatment tools for experimental data
    """
    def __init__(self, path_to_exp_data):
        self.__path_to_exp_data = path_to_exp_data
        print "Reading experimental data in " + self.__path_to_exp_data
        # self.label = self.__path_to_exp_data.split("/")[-1]
        self.label = "Experience"  # todo : changer en param du constructeur
        # Lecture du fichier
        self._exp_data = np.loadtxt(self.__path_to_exp_data, skiprows=1)
        # Verification de la structure du fichier de donn�es
        self._shape = self._exp_data.shape
        if self._shape[1] != 2:
            raise ValueError("""Experimental file has to have 2 columns : time and velocities""")
        else:
            self._time = self._exp_data[:, 0]
            self._velocity = self._exp_data[:, 1]

    def plot_experimental_results(self, fig_id, color="black"):
        """
        Plot the experimental data on figure fig_id
        :param fig_id: int
        :param color: couleur pour tracer les r�sultats, black par d�faut
        :return:
        """
        plt.figure(fig_id)
        # plt.plot(self._time, self._velocity, '--', label="Experiment", marker=' ', color=color)
        plt.plot(self._time, self._velocity, '-', label="{:}".format(self.label), marker=' ', color=color)
        # plt.plot([0, 0])  # pour recaler l'�chelle et faire apparaitre le point (t=0, v=0)
        plt.legend()

    def compute_us1_us2(self):

        # algorithme de recherche qui d�termine la "pente" entre 2 points exp�riementaux.
        # on regarde les tendances sur des paquets de 10 points consecutifs

        pente = self._velocity[1:] - self._velocity[:-1]
        # moyenne sur un groupe de n stencil mailles
        stencil = 3
        pente_moyenne = np.zeros([len(pente) / stencil])
        vitesse_moyenne = np.zeros([len(pente) / stencil])
        # import ipdb ; ipdb.set_trace()
        for i in range(len(pente)):
            print i
            vitesse_moyenne[i % stencil] += self._velocity[i] / stencil
            pente_moyenne[i % stencil] += pente[i] / stencil

        seuil = 1.e-5
        pente_positive = pente_moyenne >= seuil
        pente_negative = pente_moyenne < - seuil
        pente_nulle = pente_positive * pente_negative

        changement_pente_creux = (pente_negative[:-1] * pente_positive[1:])
        changement_pente_bosse = (pente_positive[:-1] * pente_negative[1:])

        index_moyen_creux = np.where(changement_pente_creux)[0]
        index_moyen_bosse = np.where(changement_pente_bosse)[0]

        us1 = vitesse_moyenne[index_moyen_creux[0]]
        us2 = vitesse_moyenne[index_moyen_bosse[1]]

        return us1, us2

    def compute_spall_stress(self, rho_0, c_0, us1=None, us2=None):
        """
        :param rho_0: initial density
        :param c_0: initial sound velocity
        :param us1: max velocity
        :param us2 : min velcoity after spall drop
        :return: the spall stress (contrainte � rupture lors de  l'�caillage)
        """
        if us1 is None and us2 is None:
            us1, us2 = self.compute_us1_us2()
        print "us1 is {:} m/s".format(us1)
        print "us2 is {:} m/s".format(us2)
        print "applying formula : 1/2 * rho0 * c0 * (us1 - us2)"
        spall_stress = 0.5 * rho_0 * c_0 * (us1 - us2)
        print "Spall stress computed from experimental data is {:} GPa".format(spall_stress * 1.e-9)
        return spall_stress

    @staticmethod
    def compute_polaire_de_choc(rho_0, c_0, s, u_p):
        """
        Compute the hugoniot curve to determine the pressure and velocity of the interface
        :param rho_0: ref density
        :param c_0: ref sound velocity
        :param s: s parameter of the  Mie Gruneisen EOS
        :param u_p: projectile material velocity
        :return: pressure in the hugoniot (directe)
        """
        u = np.linspace(0, u_p, int(1.e+6))
        return np.array(rho_0 * (c_0 + s * u) * u)

    @staticmethod
    def plot_hugoniot(case):
        """
        Plot the direct and indirect hugoniot curves to determine the
        :param case : nom du cas � �tudier
        :return:
        """
        # Lecture du fichier de donn�es
        data = DataContainer(os.path.join(case.directory_name, "XDATA.xml"))
        # lecture des dictionnaires MieGruneisenParameters
        eos_proj_parameters = data.material_projectile.constitutive_model.eos.eos_param
        rho_proj = eos_proj_parameters.rhozero
        c_proj = eos_proj_parameters.czero
        s_proj = eos_proj_parameters.S1
        eos_cible_parameters = data.material_target.constitutive_model.eos.eos_param
        rho_cible = eos_cible_parameters.rhozero
        c_cible = eos_cible_parameters.czero
        s_cible = eos_cible_parameters.S1

        u_proj = data.material_projectile.initial_values.velocity_init

        # Calcul de la pression sur l'hugoniot
        u = np.linspace(0, u_proj, int(1.e+6))
        p_cible = ExperimentalData.compute_polaire_de_choc(rho_cible, c_cible, s_cible, u_proj)
        p_proj = ExperimentalData.compute_polaire_de_choc(rho_proj, c_proj, s_proj, u_proj)
        p_proj_inverse = p_proj[::-1]
        p_proj = p_proj_inverse

        difference = p_cible - p_proj
        if p_cible[0] > p_proj[0]:
            # changement pour que la diff�rence soit toujours n�gative puis positive
            difference = - difference
        index = np.where((difference < 0))[0][-1]
        # l'index est repr�r� par le changement de signe de la diff�rence p_cible - p_proj
        u_inter = u[index]
        p_inter = p_cible[index]

        # Trac� des polaires de choc pour le cas
        plt.figure(99)
        plt.plot(u, p_cible, label="polaire directe (cible)")
        plt.plot(u, p_proj, label="polaire indirecte (projectile)")

        # Trac� de l'intersection des courbes
        plt.plot([0, u_inter], [p_inter, p_inter], '--', color="black")
        plt.plot([u_inter, u_inter], [0, p_inter], '--', color="black")

        # L�gende et titre des axes
        plt.title("Polaires de choc {:}".format(case.case_name))
        plt.xlabel("Vitesse [m/s]")
        plt.ylabel("Pression [Pa]")
        plt.legend()

